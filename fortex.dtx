% \iffalse meta-comment
%
% Copyright (C) 2022 by Skippi \url{https://github.com/Skipp1/fortex}
% ---------------------------------------------------------------------------
% This work may be distributed and/or modified under the
% conditions of the LaTeX Project Public License, either version 1.3
% of this license or (at your option) any later version.
% The latest version of this license is in
%   http://www.latex-project.org/lppl.txt
% and version 1.3 or later is part of all distributions of LaTeX
% version 2005/12/01 or later.
%
% This work has the LPPL maintenance status `maintained'.
%
% The Current Maintainer of this work is Skippi.
%
% This work consists of the files fortex.dtx and fortex.ins
% and the derived filebase fortex.sty.
%
%
%<*driver>
\documentclass[cm-default]{l3doc}
\usepackage{fortex}
% \usepackage[scale=0.85]{sourcecodepro} % sourcecodepro is a little bit bigger than CM 
\usepackage{microtype}
\usepackage{bookmark}
\EnableCrossrefs
\begin{document}
  \DocInput{\jobname.dtx}
\end{document}
%</driver>
% \fi
%
% ^^A Misc changes
% \changes{0.0.5$\alpha$}{2022/03/26}{Initial conversion to .dtx}
% \changes{0.0.3$\alpha$}{2022/03/10}{Move to git}
% \changes{0.0.2$\alpha$}{2022/03/02}{Translate to \pkg{expl3}}
% \changes{0.0.1$\alpha$}{2022/02/27}{Initial prototype in \LaTeXe{}}
%
%
% \title{The \pkg{fortex} package}
% \GetFileInfo{fortex.sty}
% \author{By Skippi
%         \texorpdfstring{\url{https://github.com/Skipp1/fortex}}
%                        {https://github.com/Skipp1/fortex}
%        }
% \date{\fileversion{} Released \filedate{}}
%
% \maketitle
%
% \begin{documentation}
%
% \section{Introduction}
%
% \pkg{fortex} is a language agnostic way of coding other languages in a literate way in \LaTeX{}.
% Previous Literate programming tools each have their own strengths and weaknesses. 
% \pkg{CWEB}/\pkg{noweb} for example while very powerful and cool, also very complex and quite difficult to learn.
% On the other side of the coin you have notebooks -- Jupyter and Mathmatica for example.
% These whilst simple to learn, the notebook has problems with opening in plain text editors and have issues with ``run each cell in tern'' and have no easy language agnosticism. 
% The notebook interface is also annoying and neither Jupyter or Mathmatica provide a good editing experience.
%
% \pkg{fortex} aims to bridge the gap between the two by providing the plain text editing experience and two-way compile from \pkg{WEB}/\pkg{noweb} and combine with the easy to use notebook. The end result I anticipate will be similar to \LaTeX{}'s \pkg{doc} package, but without the commenting syntax or the \LaTeX{} specificness.
%
%
% \section{Usage}
%
% TODO:
% \begin{function}{\vindex}
% \begin{syntax}
% \cs{vindex}\Arg{index entry}
% \end{syntax}
% \end{function}
%
% \begin{function}{\setfortex}
% \begin{syntax}
% \cs{setfortex}\Arg{\pkg{minted}/\pkg{listings} options}
% \end{syntax}
% \end{function}
% 
% \begin{environment}{code}
% \begin{syntax}
% |\begin{code}|
% \qquad \meta{code}
% |\end{code}|
% \end{syntax}
% \end{environment}
%
% \begin{environment}{codeblock}
% \begin{syntax}
% |\begin{codeblock}|\Arg{block name}
% \qquad \meta{block definition}
% |\end{codeblock}|
% \end{syntax}
% \end{environment}
%
% \section {Things left to do}
%
% \begin{enumerate}
% \item{Finish of |.dtx| by adding Usage instructions}
% \item{Get line numbering working}
% \item{Short verbatim (preferably default "|" with highlighting, and |"| without) should be configurable}  
% \item{Defines / Used linking: \\ 
% This should do 2 things - emulate the begin\{macro\} from the \pkg{doc} class.
% (in the sense it automatically adds to the index, but also we should be able to say ``this function'' was used in ``these locations'')}
% \item{Allow multiple files in the same document (e.g. |.c| and |.h| files)---still need to figure out an interface (this will probably require changing the outputted filename in the \env{code} environment)}
% \item{Code definitions earlier on in the document (more of a traditional standalone documentation thing)}
% \item{Changelog interface (just a wrapper for glossaries)?}
% \item{Automated Regression Testing}
% \end{enumerate}
%
% \paragraph{What I will be working on next:}
% A \pkg{doc}--like interface that is a bunch of environments that allow linking and documentation similar to \tn{macro}, and \tn{variable} environments from the \pkg{doc} package. 
%
% Envs to include:
% Function, Method, Class, Variable, Macro, Interface, Module(?), Namespace, file(?)  
%
% Optional Arguments:
% \begin{itemize}
% \item nonest
% \item internal/external 
% \item noindex
% \item pure (only function/macro/method?)
% \item Arbitrary text? 
% \end{itemize}
%
% Also provide generic version that can be customised. 
% The plan is for this to eventually be used by a |\uses| macro that will automatically add links to the index and hyperref links to the definition.
%
%
% \paragraph{shortverb with highlighting}
%
% I found this, on stack exchange and could be useful in making a version of shortverb that does highlighting.
%
% \url{https://tex.stackexchange.com/questions/524645}
%
% \begin{verbatim}
% \documentclass{article}
%
%\usepackage{minted}
%
%\newmintinline[code]{latex}{}
%
%\catcode`\|=\active
%\protected\def|{%
%  \ifmmode
%    \expandafter\@firstoftwo
%  \else
%    \expandafter\@secondoftwo
%  \fi
%  {\string|}{\code|}%
%}
% \end{verbatim}
%
%
% \paragraph{Interface ideas for multiple files:}
% Looking at how \pkg{noweb} implements its multiple files 
%
% \begin{verbatim}
% << file.c >> = 
% ...
% @
% << file.h >> = 
% ...
% @
% \end{verbatim}
% 
% So I am thinking that the \LaTeX{} equivalent would be a |\begin{outfile}{file.c}| kind of interface.
% However, I am not in love with this and I would want to avoid this being mandatory. 
% I am yet to check other literate programming styles for how they implement this.
%
% \end{documentation}
%
% \begin{implementation}
% \section{\pkg{fortex} Implementation}
%
% \pkg{DocStrip} guards.
%    \begin{macrocode}
%<*package>
%<@@=fortex>
%    \end{macrocode}
%
% \subsection{Initial set up}
% As this is an \pkg{expl3} package, we need to load that.
% Please note that I am currently developing this on \TeX{}Live 2022, and not paying a huge amount of attention to version compatibility, so your mileage may vary.
% (maybe in the future once this is all done I will switch to older features for older \TeX{}Live installs, but as of now anything before \TeX{}Live 2022 is not officially targeted.)
%
% As of version 0.0.6$\alpha$, anything before \TeX{}Live 2022 is broken.
% I do plan to backport to \TeX{}Live 2015 as that is what the stable distros seem to be using but for now this is all there is.
%    \begin{macrocode}
% \RequirePackage[enable-debug]{ expl3 }
\RequirePackage{ expl3 }
\RequirePackage{ l3benchmark }
\ProvidesExplPackage {fortex} {2022-03-27} {0.0.7$\alpha$}
{like noweb without external tooling}
%    \end{macrocode}
%
%    \begin{macrocode}
\RequirePackage { l3keys2e }
%    \end{macrocode}
%
% The package \pkg{fancyvrb} is required to write stuff to file and to define custom-named verbatim environments.
% I know \pkg{minted} loads this package (I haven't checked \pkg{listings}, but it would not surprise me if they loaded this package too). 
% As far as I am aware, this is only used in \env{code}, with \tn{VerbatimEnvironment} and \tn{VerbatimOut}.
%
%    \begin{macrocode}
\RequirePackage { fancyvrb }
%    \end{macrocode}
%
% \subsection{Package options}
%
% As of now this is the initial package level settings.
% I do plan to expand this and/or move some of it next to the \env{code} environment itself.
% Doing that would allow one |.tex| file to make both |.c| and |.h| files.
% However, I still need to give some thought into how that is all going to work (interweaving |.c| and |.h| is probably going to get confusing).
%
%    \begin{macrocode}
% \debug_on:n {all}
\keys_define:nn { fortex } {
%    \end{macrocode}
%
% \begin{variable}{\g_@@_verbose_bool}
% This flag is mainly used for debugging.
% It prints the contents of the \env{code} environment and |-output-dir| to the terminal in order to help see what is going on.
% 
% Default: |False| 
%
%    \begin{macrocode}
  verbose .bool_gset:N = \g_@@_verbose_bool,
  verbose .default:n  = { true },
  verbose .initial:n  = { false },
%    \end{macrocode}
% \end{variable}
% 
% \changes{0.0.3$\alpha$}{2022/03/8}{Add \pkg{listings}/\pkg{minted} option}
% \begin{variable}{\g_@@_printend_tl}
% This flag governs what package will be used for typesetting the resulting pdf. 
% At the moment the options are \pkg{minted} and \pkg{listings}. 
% 
% I have also defined a bunch of aliases for these packages, mostly because I am too lazy to type out the full name of the package and I find it leads to preamble bloat. 
% The full list of aliases can be found in the definition of \cs{g_@@_printend_tl}
% 
% Default: \pkg{listings}
%    \begin{macrocode}
  print .tl_gset:N  = \g_@@_printend_tl,
  print .default:n = { listings },
  print .initial:n = { listings },
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\g_@@_lang_tl}
% This is the setting that determines what language we are going to be setting.
% This is used for 2 things:
%
% \begin{enumerate}
% \item {Automatic file extensions}
% \item {Passing to \pkg{minted}/\pkg{listings} for syntax highlighting}
% \end{enumerate}
%
% Default: |text|
%
%    \begin{macrocode}
  lang .tl_gset:N  = \g_@@_lang_tl,
  lang .default:n = { text },
  lang .initial:n = { text },
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\g_@@_ext_tl}
%
% By default we do a mediocre job of detecting the extension for the language.
% Moreover, in some cases (e.g. |.c| and |.h|) there is no way to detect the extension from the language (both are ``C'').
% So we provide a way to manually override the extension.
%
% \begin{itemize}[label={}]
% \item{Default if language with known extension: \{\}}
% \item{Default if language with unknown extension: .txt}
% \end{itemize}
%
%    \begin{macrocode}
  ext .tl_gset:N  = \g_@@_ext_tl,
  ext .initial:n = {},
  ext .default:n = {},
%    \end{macrocode}
% \end{variable}
%
% \changes{0.0.6$\alpha$}{2022/03/21}{Create automatic insertions of hyperref into minted/listings}
% \begin{variable}{\g_@@_intext_bool}
%    \begin{macrocode}
  ext .bool_gset:N  = \g_@@_intext_bool,
  ext .initial:n = { true },
  ext .default:n = { false },
}
%    \end{macrocode}
% \end{variable}
%    \begin{macrocode}
\ProcessKeysOptions { fortex }
%    \end{macrocode}
% \subsection{Engine specific warnings}
%
% Unfortunately we have a few issues using  \XeTeX{} \pTeX{} and \upTeX{} due to these engines not using real tab characters when printing to files. 
% As far as I am aware there is no easy way to directly solve this from within latex, and we just need to warn the user that tab characters may become |\^^I| when using these engines. 
% 
% On \XeTeX{} this seems to be resolved by using |-8bit|, however I am not sure about \pTeX{} and \upTeX{}.
% 
% This problem is known about and it affected \pkg{minted} independent of what we are doing over here in \pkg{fortex}.
%
% \begin{tabular}{l}
% \url{https://tex.stackexchange.com/questions/14771} \\
% \url{https://tex.stackexchange.com/questions/58732} \\
% \url{https://tex.stackexchange.com/questions/264461}\\
% \end{tabular}
%
% Note: We only warn the user if they have enabled the |verbose| settings.
% This is at the moment not super optimal as they may not think to do this, However I also don't want to spam them with messages if they are using spaces instead. 
%
% Maybe a better way to fix this problem is to detect the string ``|^^I|'' in the file we read back and then only warn if we see it?
%
% \changes{0.0.3$\alpha$}{2022/03/14}{Add warnings about \XeTeX{}, \pTeX{} and \upTeX{} and their handling of tabs}
%
%    \begin{macrocode}
\bool_if:nT { \g_@@_verbose_bool } {
  \msg_new:nnn { fortex } { itab } {
    #1 ~ has ~ problems ~ printing ~ tabs ~ to ~ files. ~
    ~ (tabs ~ may ~ turn ~ into ~ \c_circumflex_str \c_circumflex_str I) ~
    ~ Executing ~ with ~ -8bit ~ may ~ fix ~ this.
  }
  \str_case_e:nnT { \c_sys_engine_str } {
    { ptex  } {}
    { uptex } {}
    { xetex } {}
  } {
    \msg_warning:nnx { fortex } { itab } { \c_sys_engine_str }
  }
}
%    \end{macrocode}
%
% \subsection{Getting \texttt{-output-dir}}
%
% \changes{0.0.4$\alpha$}{2022/03/15}{Add -output-dir detection}
%
% If \LaTeX{} is used with |-output-directory|, \cs{sys_shell_now:x} |{mkdir ...}| will ignore it and make its directory in the .tex directory.
% However, \tn{VerbatimOut} will write to the file indicated by |-output-directory|.
% This causes problems if \tn{VerbatimOut} tries to write into our newly made directory.
%
% I encountered this issue when using the \LaTeX{} editor \pkg{kile} as it uses the |-output-directory| argument to build in the |/tmp/kile-livepreview.abcde/| directory.
% This was causing issues, as I was not longer able to use my favourite \LaTeX{} editor with \pkg{fortex}. 
%
% \paragraph{The hacky solution}
% We try to work around this by using a little bit of regex and a quirk of log files:
% For this example let the command be:
%
% \begin{verbatim}
% latex -output-dir=outdir jobdir/jobname.tex
% \end{verbatim}
%
% If there is a \file{jobname.log} file already in the \file{jobdir/} folder then \file{jobname.log} will list the lines:
%
% \begin{verbatim}
% (/path/to/jobdir/jobname.log)
% \openout1 = `jobname.log'.
% \end{verbatim}
%
% As it mistakes the \file{jobdir/} file for the one that is actually writing to.
% However, if \file{jobname.log} \emph{is not} already in \file{jobdir/} it is a different story:
%
% \begin{verbatim}
% (/path/to/outdir/jobname.log)
% \openout1 = `jobname.log'.
% \end{verbatim}
%
% Moreover, \file{jobname.log} will always have the string
%
% \begin{verbatim}
% /path/to/jobdir/jobname.tex
% \end{verbatim}
%
% From this logging behaviour, we can tell if \LaTeX{} was run using |-output-dir|, and if so what the value of it is.
%
% \paragraph{Things to note about this hack} 
%
% \begin{itemize}
%
% \item { This trick \emph{only} works if there is not \file{jobname.log} in \file{jobdir/}.
% With \pkg{fortex}, we can check if this is a first time run by checking the presence of a test file.
% But if you are copying this code into your own \LaTeX{} file you will need to make sure that you have a clean \file{jobdir/}. }
%
% \item { This command cannot be executed on setup - very sad, as the \file{jobname.log} file is not written instantly, but it takes some time for the lines to begin appearing. 
% As such we call this on the first call to out \env{code} environment }
%
% \item { This seems to be crashing on \XeTeX{} with the error:
% \begin{verbatim}
% ! Bad register code (32768)
% A register must be between 0 and 32767
% TODO: FIXME
% \end{verbatim}
% }
%
% \item { Calling the actual function \cs{@@_outputdir_auxi:} is \emph{very} slow, especially if the log file is large (e.g. loading lots of packages). 
% So it's important that the value is cached in \file{jobname.aux} }
%
% \item { This logfile trick doesn't work on \LuaTeX{} due to \tn{kpse.find_file} not detecting files in \file{outdir/}.
% However, this is not a huge issue as the lua extensions provide an interface to the arguments that \LuaTeX{} was called with. }
% \end{itemize} 
%
%
% \paragraph{The \texttt{-output-dir} implementation}
%
% One thing that we want to try and make sure, is that the line ``\file{jobname.log}'' appears early in the logfile to prevent excessive regexing. 
% Note: |ior_*| and |iow_*| functions don't cause this effect.
% Ideally we would avoid reading the entire file just to print it in the log, but at the moment this seems to work.
% 
%    \begin{macrocode}
\file_get:nnN { \c_sys_jobname_str .log } {} \l_tmpa_tl
%    \end{macrocode}
% \begin{variable}{\g_@@_outputdir_tl}
% This is the return variable that will be referenced later on in \cs{@@_printcode:nnn}, \cs{@@_mktmpdir:} and the \env{code} environment.
% 
%    \begin{macrocode}
\tl_new:N \g_@@_outputdir_tl
%    \end{macrocode}
% \end{variable}
%
% \begin{macro}{\@@_outputdir:}
% \begin{variable}[internal]{\fortex@outputdir}
%
% As previously mentioned the actual function that checks \file{jobname.log} file is \emph{very} slow.
% So we do the easy thing and cache to the log file. 
%
% Note that by doing this we need to do some cache invalidating later in case we forget to delete the file already in \file{jobdir/}. 
% 
% Finally we are caching to aux using \LaTeXe{} syntax in order to avoid needing to declare an \pkg{expl3} environment in the aux file.
%

%    \begin{macrocode}
\cs_set:Nn \@@_outputdir: {
  \tl_if_exist:NTF { \fortex@outputdir } {
    \tl_gset:Nx \g_@@_outputdir_tl { \fortex@outputdir }
%    \end{macrocode}
%
% \paragraph{Cache Invalidation}
%
% If the code has been run before \cs{g_@@_outputdir_tl} will be cached, but also out test file \file{_fortex-jobname/jobname-0.tmp} used in \cs{@@_mktmpdir:} will be present.
%
% If the test file is not present, then chances are the value in the aux file is invalid. 
% (or is the user has deleted \file{_fortex-jobname/}, but that happens rare enough that I don't feel bad invalidating the cache when that happens) 
%
%    \begin{macrocode}
    \file_if_exist:nF {\g_@@_outputdir_tl
                       \c_@@_tmpfolder_tl/\c_sys_jobname_str -0.tmp 
    }{
      \@@_outputdir_aux:
    }
  }{
    \@@_outputdir_aux:
  }
%    \end{macrocode}
% Then we cache the new value to aux.
% Note that we are using \LaTeXe{} syntax in order to avoid writing excess \cs{ExplSyntaxOn} into the aux file.
%
%    \begin{macrocode}
  \iow_now:cx { @auxout } {
     \exp_not:n { \gdef\fortex@outputdir }
   { \exp_not:V { \g_@@_outputdir_tl } }
  }
  \bool_if:NT \g_@@_verbose_bool {
    \iow_term:x { -output-dir~path:~ \exp_not:V { \g_@@_outputdir_tl } }
  }
}
%    \end{macrocode}
%
% \end{variable}
% \end{macro}
%
% \begin{macro}{\@@_outputdir_aux:}
%
% This function mainly exists to prevent writing the case statement a few times. 
% The case statement exists due to problems with the \LaTeX{} engines that need workarounds.
% Note that if we are on this codepath it means that we have either not found |-output-dir| in the cache, or the cache was found to be invalid.
%
% \begin{itemize}[label=\textit{Note}:\ ]
%   \item {\XeTeX{} has problems with regexing large files, as of yet I cannot find a workaround.}
%   \item {\LuaTeX{} has problems reading from |-output-dir| (no biggie, just fall back on lua extensions).} 
%  \end{itemize}
%
%    \begin{macrocode}
\cs_set:Nn \@@_outputdir_aux: {
  \str_case_e:nn { \c_sys_engine_str } {
%    \end{macrocode}
% Firstly we run engine specific code to work around \XeTeX{} and \LuaTeX{} problems.
%
%    \begin{macrocode}
    { luatex } { \@@_outputdir_lua_auxi: }
    { ptex   } { \@@_outputdir_auxi: }
    { pdftex } { \@@_outputdir_auxi: }
    { uptex  } { \@@_outputdir_auxi: }
    { xetex  } { \tl_gset:Nn \g_@@_outputdir_tl {} }
  }  
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_outputdir_lua_auxi:}
%
% This is the LuaTeX{} specific function to get the |-output-dir|. 
% This is a lot easier to get compared to the other engines as \LuaTeX{} directly exposes what arguments it was called with inside its lua extensions.
%
% Here we only use a little lua as I have never used lua before and its just easier for me to keep it in \TeX{}.
% The important part however, is that we can use |tex.print(arg)| to insert into the input stream the arguments that \LuaTeX{} was called.
%
% \begin{verbatim}
% \lua_now:n{ tex.print(arg) }
% \end{verbatim}
% will for example return
%
% \begin{verbatim}
% lualatex -synctex=1 -output-directory=outdir jobname.tex
% \end{verbatim}
% as a token list.
%
% Finally, we use some regex to extract the |-output-dir| value.
% Ideally we would use lua here and in some guides on the internet one is able to index by name: e.g. |arg["output dir"]|. 
% However, at least on my installation of \LuaTeX{} I was only given the option to index by argument number. 
% As there is no way for us to make sure |-output-dir| will always have the same index we resort to regex.
%
% Note that as I said I do not know any lua, and there may very well be an easy way that I am just missing.
%
%    \begin{macrocode}
\cs_set:Nn \@@_outputdir_lua_auxi: {
  \tl_set:Nn \l_tmpa_tl { \lua_now:n { tex.print(arg) } }
%    \end{macrocode}
% Note that we use the regex ``|--?output-dir(ectory)?|'' due to \LuaTeX{} taking a few different forms of the |-output-dir| argument.
% (Sometimes we lead with two dashes |--| or one dash |-|, or we may use |output-dir| or |output-directory|.
% There may be a few other variations that I am not considering or have just missed.
% However, this should cover the majority of the cases)
%
%    \begin{macrocode}
  \exp_args:Nnf \regex_extract_once:nnN
                {--?output-dir(ectory)?=([-\.\w+/]*)}
                { \l_tmpa_tl } \l_tmpa_seq
%    \end{macrocode}
%    \begin{macrocode}
  \seq_get_right:NN \l_tmpa_seq \l_tmpa_tl
%    \end{macrocode}
% If the regex is unable to find anything it will return a \cs{q_no_value}, and so we need to check for that.
% If we do not and naively, set the value to \cs{g_@@_outputdir_tl}, we will try to write our files into a folder called ``|\q_no_value|''.
%
%    \begin{macrocode}
  \quark_if_no_value:NF \l_tmpa_tl {
    \tl_if_empty:NF \l_tmpa_tl { 
      \tl_gconcat:NNN \g_@@_outputdir_tl \l_tmpa_tl /
    }
  }
}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\@@_outputdir_auxi:}
%
% The actual function called for all other engines except \LuaTeX{} and \XeTeX{}. 
% This function is mostly a hack to work around the limitations of the \LaTeX{} systems. 
% 
% I have tried searching is there is any better way to do this, and the only solution I have come up with is to not write these functions in the first place. 
% The main issue with that is that there is no good way to handle verbatim environments and pass it to two functions.
% As such we need to write the contents to a file then read it back out.
% However, now you have problems with race conditions.
% So the solution is to write the content to several files (minted already does this.) and to keep it tidy put it all in a folder. 
%
% In any case, this function is ugly but at the moment needs to exist.
%    \begin{macrocode}
\cs_set:Nn \@@_outputdir_auxi: {
  \tl_new:N \l_@@_reallogpath_tl
  \tl_new:N \l_@@_realtexpath_tl
%    \end{macrocode}
% The fist thing that we do is to read the \file{jobname.log} file. 
% Strictly setting the \tn{endlinechar} catcodes shouldn't be necessary.
% However, it makes debugging by printing the contents of \file{jobname.log} to the terminal.
%
%    \begin{macrocode}
  \file_get:nnN { \c_sys_jobname_str .log } {
    \endlinechar=`\^^J
    \char_set_catcode_other:N \^^J
  } \l_tmpa_tl
%    \end{macrocode}
% If \cs{file_get:nnN} is unable to find the file, it returns \cs{q_no_value}.
% This is problematic for later on and if not handled, it will cause hangs.
%
%    \begin{macrocode}
  \quark_if_no_value:NF \l_tmpa_tl {
    \tl_if_empty:NF \l_tmpa_tl { 
%    \end{macrocode}
% First thing that we do is get the full path of \file{jobname.log}
%    \begin{macrocode}
      \exp_args:Nno \regex_extract_once:nnN {\.?/?[-\.\w+/]*\.log}
                                            { \l_tmpa_tl } \l_tmpa_seq
%    \end{macrocode}
%    \begin{macrocode}
      \seq_get:NN \l_tmpa_seq \l_@@_reallogpath_tl
%    \end{macrocode}
% First thing that we do is get the full path of \file{jobname.tex}
%
%    \begin{macrocode}
      \exp_args:Nno \regex_extract_once:nnN {\.?/?[-\.\w+/]*\.tex} 
                                            { \l_tmpa_tl } \l_tmpa_seq
%    \end{macrocode}
%    \begin{macrocode}
      \seq_get:NN \l_tmpa_seq \l_@@_realtexpath_tl
%    \end{macrocode}
% The contents of \file{jobname.log} can be very large and can cause \TeX{} to run out of memory if we are not careful. 
% Thus even if \cs{l_tmpa_tl} is going to be used later, it is a good idea to clear it the moment that we are done.
%
%    \begin{macrocode}
      \tl_clear:N \l_tmpa_tl
%    \end{macrocode}
% Finally we strip the filenames (\file{jobname.tex}/ \file{jobname.log}) from the end of the paths - makes it easier to check if log is in a different directory.
% Here the scratch variable \cs{l_tmpa_tl} is only used to match the function signature and is not used anywhere else. 
% We only care about the leading path to the files anyway.
%
%    \begin{macrocode}
      \file_parse_full_name:VNNN { \l_@@_reallogpath_tl } 
                                   \l_@@_reallogpath_tl 
                                   \l_tmpa_tl \l_tmpa_tl
%    \end{macrocode}
%    \begin{macrocode}
      \file_parse_full_name:VNNN { \l_@@_realtexpath_tl }
                                   \l_@@_realtexpath_tl
                                   \l_tmpa_tl \l_tmpa_tl
%    \end{macrocode}
% Finally return the location of |-output-dir=outdir| if we have one, otherwise return nothing.
% Ideally this would be a little more structured and not rely on \cs{g_@@_outputdir_tl} globals as much.
%
%    \begin{macrocode}
      \str_if_eq:NNF { \l_@@_reallogpath_tl } 
                     { \l_@@_realtexpath_tl } {
        \tl_gset:Nx  \g_@@_outputdir_tl { \l_@@_reallogpath_tl / }
      }
    }
  }
}
%    \end{macrocode}
% \end{macro}
% \subsection{Code printing}
% 
% The next collections of functions is to do with the code printing and how it is displayed in the \file{.pdf} itself.
% Most of the functions are about switching between \pkg{minted} and \pkg{listings}. 
%
% \changes{0.0.3$\alpha$}{2022/03/08}{Add \pkg{listings}/\pkg{minted} option}
% \changes{0.0.6$\alpha$}{2022/04/02}{Be more structured}
% \begin{variable}{\g_@@_printend_tl}
%
% This next code Section defines a bunch of aliases for switching between \pkg{listings} and \pkg{minted}.
% This is because I tend to be lazy and like to shorthand stuff as opposed to write out the full name.
% 
% If an invalid key is found, we default to \pkg{listings} mainly because it is the older/more established package. 
% \pkg{listings} also has the advantage of not requiring |-shell-esc| and I would like to avoid as much |-shell-esc| as possible.
%
% 
%    \begin{macrocode}
\msg_new:nnn { fortex } { printend } {
  Unknown ~ keyval ~ "print=#1". ~ defaulting ~ to ~ "print=listings"
}
\str_gset:Nx \g_@@_printend_tl {
  \str_case_e:nnF { \g_@@_printend_tl} {
    { minted      }{ mint }
    { mint        }{ mint }
    { m           }{ mint }
    { lstlistings }{ lst  }
    { lstlisting  }{ lst  }
    { listings    }{ lst  }
    { listing     }{ lst  }
    { lst         }{ lst  }
    { l           }{ lst  }
  }{
    lst
    \msg_warning:nnx { fortex } { printend } { \g_@@_printend_tl }
  }
}
%    \end{macrocode}
% \end{variable}
%
% \changes{0.0.6$\alpha$}{2022/04/01}{Fix minted caching}
%
% We now laod the required highlighting/formatting package.
% I wanted to avoid only relying on one backend. 
% (Mainly because I prefer minted, but requiring |-shell-esc| should not be a hard requirement).
%
% Note: we set the \pkg{minted} cache to the current folder ``\file{.}'' to prevent it from making any new folders. 
% At the first call of the \env{code} environment \cs{@@_firstcall:}, we calculate the output directory we will be using and update the cache location before that call. 
%
% Note: This now introduces a new bug where any calls to minted before the code environment will cause the minted cache to appear in the \file{jobdir/} folder.
% This should be solvable with a hook at the start of the \env{document} environment, but I need to figure out some stuff with the output dir calculations. 
%
%
%    \begin{macrocode}
\str_if_eq:NNTF { \g_@@_printend_tl } { mint } {
  \RequirePackage { minted }
}{
  \RequirePackage { listings }
}
%    \end{macrocode}
%
% \changes{0.0.6$\alpha$}{2022/04/01}{Fix minted caching}
%\begin{macro}{\@@_printcode:nnn}
% \begin{arguments}
% \item{ keyvals to pass to \pkg{minted}/\pkg{listings} (must be expanded with \cs{exp_args:No} when this function is called)}
% \item{ programming language we want to highlight}
% \item{ tmp filename we are going to use (absolute path)}
% \end{arguments}
%
% Load the saved tmp file and do all the highlighting/formatting and then place into the pdf.
% Note that we need to pass the full path when using |-output-dir|.  
%
% \begin{itemize}[label={Bugs:}]
% \item{This function is weird, and I have no idea why |:onn| or |:xnn| signatures don't work?
%       but calling \cs{exp_args:No} \cs{@@_printcode:nnn} does work?}
% \end{itemize}
%
%    \begin{macrocode}
\cs_set:Npn \@@_printcode:nnn #1#2#3 {
  \str_if_eq:NNTF { \g_@@_printend_tl } { mint } {
    \tl_set:Nn \minted@cachedir {\g_@@_outputdir_tl \c_@@_tmpfolder_tl}
    \@@_codesafedelim:N \l_tmpa_str
    \inputminted [escapeinside={\l_tmpa_str \l_tmpa_str}, #1 ] { #2 } { #3 }
  }{
    \str_if_eq:NNTF { #2 } { text } {
%    \end{macrocode}
% \pkg{listings} doesn't support no highlighting by setting the key |language=text|, so we need to explicitly \emph{not} pass in a language key. 
%
%    \begin{macrocode}
      \lstinputlisting [ #1 ] { #3 }
    }{
      \lstinputlisting [ language=#2, #1 ] { #3 }
    }
  }
}
%    \end{macrocode}
% \end{macro}
%
% \subsection{Setting up filenames}
%
% \changes{0.0.2$\alpha$}{2022/03/04}{Add extension detection}
% \changes{0.0.6$\alpha$}{2022/04/02}{Be more structured}
% \begin{variable}{\g_@@_ext_tl}
%
% We guess the file extension defaulting to |.txt| if we don't know.
% The file extension can be explicitly overwritten using the package level option |ext|.
% 
% I need to add more language / file extensions relations, but these are all the ones I will use myself.
% I cannot for now be bothered to add any more language/extension pairs.
% A smarter way might be to have an external datafile of all the language/extension pairs, but for now this will do.
% If anyone else wants to add a language for autodetection, go ahead.
%
%    \begin{macrocode}
\tl_if_empty:NT \g_@@_ext_tl {
  \msg_new:nnn { fortex } { language } {
    Unable ~ to ~ guess ~ file ~ extension ~ for ~ "language=#1". ~
    ~ defaulting ~ to ~ .txt
  }
  \tl_gset:Nx \g_@@_ext_tl { 
    \str_case_e:nnF { \g_@@_lang_tl } {
      { python       }{ py  }
      { fortran      }{ f90 }
      { fortranfixed }{ f   }
      { bash         }{ sh  }
      { text         }{ txt }
      { octave       }{ m   }
      { matlab       }{ m   }
      { cpp          }{ cpp }
      { c            }{ c   }
      { tcl          }{ tcl }
      { nasm         }{ s   }
      { makefile     }{ mk  }
    }{
%    \end{macrocode}
% We default to |.txt| extension if we cannot figure it out from the language.
%
%    \begin{macrocode}
      txt 
      \msg_warning:nnx { fortex } { language } { \g_@@_lang_tl }
    } 
  }
}
%    \end{macrocode}
%\end{variable}
%
% \begin{variable}{\c_@@_tmpfolder_tl}
% We build the folder that we save all of the tmp files into. 
% This is a constant that is of the form \file{_fortex-jobname/}.
%
%    \begin{macrocode}
\tl_const:Nn \c_@@_tmpfolder_tl {
  \c_underscore_str fortex- \c_sys_jobname_str
}
%    \end{macrocode}
% \end{variable} 
%
% \changes{0.0.3$\alpha$}{2022/03/10}{Add automatic folder creation}
%
% \begin{macro}{\@@_mktmpdir}
% If we are writing files into a folder, we need to make sure that the folder exists, and if we not we will either create it ourselves or say a warning that the folder can be created manually.
% I want to avoid explicitly depending on |-shell-esc|, so as a consequence this function is on the jankier side.  
% The main issue is that \LaTeX{} doesn't support doing anything with folders. As such we cannot check if a folder exists, or create a new folder without |-shell-esc| permissions. 
% 
% The basic idea is to check if a test file: \file{outdir/_fortex-jobname/jobname-0.tmp} exists in our output folder.
% If the folder doesn't exist the \cs{file_if_exist:nF}, will not cause any errors, but will just say the file doesn't exist. 
% If we don't find the file and we don't have |-shell-esc| permissions, we warn the user, and try to write a new test file. 
% If the folder doesn't exist trying to write to the file will cause a critical error.
%
% If we do have |-shell-esc| permissions, we create a folder and continue on our way. 
% 
%    \begin{macrocode}
\cs_set:Npn \@@_mktmpdir: {
  \file_if_exist:nF { \g_@@_outputdir_tl
                      \c_@@_tmpfolder_tl/\c_sys_jobname_str -0.tmp
  }{
    \sys_if_shell_unrestricted:TF {
      \sys_shell_now:x { mkdir~\g_@@_outputdir_tl \c_@@_tmpfolder_tl }
    }{
%    \end{macrocode}
% We throw a warning if we cannot open our test file explaining how to resolve the issue.
%
%    \begin{macrocode}
      \msg_new:nnn { fortex } { make_folder } {
        Unable ~ to ~ find ~ folder ~ "##1" ~ please ~ create ~ it ~ 
        ~ manually ~ or ~ enable ~ -shell-esc ~ to ~ create ~ automatically
      }
      \msg_warning:nnx { fortex } { make_folder } { \c_@@_tmpfolder_tl }
    }
%    \end{macrocode}
% Create file for next time, or if we do not have |-shell-esc| and the tmp folder does not exist, stop compilation.
%
%    \begin{macrocode}
    \iow_new:N   \l_@@_testfile_iow
    \iow_open:Nn \l_@@_testfile_iow { 
                 \c_@@_tmpfolder_tl/\c_sys_jobname_str -0.tmp
    }
    \iow_close:N \l_@@_testfile_iow
  }
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\@@_inctmpname:}
% \begin{variable}{\g_@@_tmp_filename_tl}
% Build the series of tmp filenames by incrementing the number on the end of the filename on every call.
% The general output is of the form \file{_fortex-jobname/jobname-1.tmp}.
% Note that there is no |-output-dir| on the front of the path.  
%
%    \begin{macrocode}
\int_new:N \g_@@_inctmpname_namecount_int
\tl_new:N \g_@@_tmp_filename_tl
\cs_set:Npn \@@_inctmpname: {
  \int_gincr:N \g_@@_inctmpname_namecount_int
  \tl_gset:Nn \g_@@_tmp_filename_tl {
    \c_@@_tmpfolder_tl /
    \c_sys_jobname_str -
    \int_to_arabic:n { \g_@@_inctmpname_namecount_int } .tmp
  }
}
%    \end{macrocode}
% \end{variable}
% \end{macro}
%
% \begin{variable}{\c_@@_out_filename_tl}
% Build the filename we are going to save the concatenated code segments to. This is \file{jobname.ext}.
%
%    \begin{macrocode}
\tl_const:Nn \c_@@_out_filename_tl
           { \c_sys_jobname_str.\g_@@_ext_tl }
%    \end{macrocode}
% \end{variable}
%
% \begin{macro}{\_@@_firstcall:}
% \begin{variable}{\g_@@_firstrun_bool, \c_@@_outfile_iow}
%
% Some setup code that should happen on the first call after everything is loaded.
% It is at this point that we figure out the |-output-dir|.
% I have tried a little running this as a hook, but I have never used hooks before and I am probs just doing something wrong. 
% 
% Only two functions need to be called, at this point:
% \begin{enumerate}
% \item{Calculating |-output-dir| }
% \item{Clearing the previous contents of the output file \file{jobname.ext}. }
% \end{enumerate}
%
% However, \cs{@@_mktmpdir:} and \tn{minted@cachedir} is also called at this point due to needing to know the |-output-dir| value. 
%
%    \begin{macrocode}
\iow_new:N \c_@@_outfile_iow
\bool_new:N   \g_@@_firstrun_bool
\bool_gset:Nn \g_@@_firstrun_bool { \c_true_bool }
\cs_set:Npn \@@_firstcall: {
  \bool_if:nT { \g_@@_firstrun_bool } {
%    \end{macrocode}
%    \begin{macrocode}
    \@@_outputdir:
%    \end{macrocode}
%    \begin{macrocode}
    \@@_mktmpdir:
%    \end{macrocode}
% 
% Set our new cache location for \pkg{minted}'s calls to \pkg{pygments} so we keep all the tmp files in one place.
%    \begin{macrocode}
    \str_if_eq:NNT { \g_@@_printend_tl } { mint } {
      \tl_set:Nn \minted@cachedir {.}
    }
%    \end{macrocode}
% Clear the previous contents of the output file \file{jobname.ext}.
%
%    \begin{macrocode}
    \iow_open:Nn \c_@@_outfile_iow { \c_@@_out_filename_tl }
    \iow_close:N \c_@@_outfile_iow
%    \end{macrocode}
%    \begin{macrocode}
    \bool_gset_false:N \g_@@_firstrun_bool
  }
}
%    \end{macrocode}
% \end{variable}
% \end{macro}
%
% \subsection{File saving}
%
% \changes{0.0.6$\alpha$}{2022/04/1}{Figure out a bunch more catcodes that need setting when reading files }
% \begin{macro}{\@@_setcatcode:}
% Set catcodes required to not mangle the file when reading.
% 
% In the below code |^^J| is a newline.
% and |^^I| is a tab character.
%
% |\| is kinda interesting as it will insert a space after the next word ``|\str|'' will turn into ``|\str |'' (note the trailing space).
% This is an issue mostly for using hyperref labels in the typeset sections.
%
% Note: This is probably not a comprehensive list, however I am yet to find any more.
% There is probably a list of all characters in a certain catcode, but for now this seems to work. 
%
%    \begin{macrocode}
\cs_set:Nn \@@_setcatcode: {
%    \end{macrocode}
% Fallback to 2$\varepsilon$ interface or \tn{endlinechar}, as \pkg{expl3} has yet to make an interface that isnt marked as do not use (|:D|)
%
%    \begin{macrocode}
  \endlinechar=`\^^J               
%    \end{macrocode}
% Try and protect some whitespace (Currently we have a few stray newlines but whatever)
%
%    \begin{macrocode}
  \char_set_catcode_other:N \^^J
  \char_set_catcode_other:N \^^I
  \char_set_catcode_other:N \ 
%    \end{macrocode}
% Prevent lines beginning with \% from being removed as comments
%
%    \begin{macrocode}
  \char_set_catcode_other:N \%
%    \end{macrocode}
% Prevent \LaTeX{} Command chars from being evaluated/expanded 
%
%    \begin{macrocode}
  \char_set_catcode_other:N \#
  \char_set_catcode_other:N \{
  \char_set_catcode_other:N \}
  \char_set_catcode_other:N \\
  \char_set_catcode_other:N \\
%    \end{macrocode}
% LaTeX{} uses commands like |^^|\meta{Letter} to indicate the \textsc{ascii} code of the letter.
% For example \c_circumflex_str\c_circumflex_str{}J corresponds to $0\times0a$ - a newline in Linux-land.
% However as we want to write this all verbatim we disable this.
% Note: Defining this catcode should be last.
%    \begin{macrocode}
  \char_set_catcode_other:N ^
}
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Writing the code to the output file}
%
% \changes{0.0.5$\alpha$}{2022/03/29}{Rename writeoutput to concat\_files}
% \begin{macro}{\@@_concat_files:}
%
% Append the contents of the tmp file to the output file.
% Ideally we would open \cs{c_@@_outfile_iow} in append mode, however \LaTeX{} does not support append mode. 
% 
% As such this function exists to emulate the effects of opening a file in append mode, by copying the previous content of the file, then writing it back with the new content.
%
% This is the function that is actually responsible for writing the output file.
%
%    \begin{macrocode}
\cs_set:Npn \@@_concat_files: {
%    \end{macrocode}
%
%    \begin{macrocode}
  \file_get:nnN { \g_@@_outputdir_tl \c_@@_out_filename_tl }
                { \@@_setcatcode: } \l_tmpa_tl
%    \end{macrocode}
%    \begin{macrocode}
  \file_get:nnN { \g_@@_outputdir_tl \g_@@_tmp_filename_tl }
                { \@@_setcatcode: } \l_tmpb_tl
%    \end{macrocode}
% Print the tmp file to terminal for debugging
%
%    \begin{macrocode}
  \bool_if:nT { \g_@@_verbose_bool }{
    \iow_term:x { \exp_not:V { \l_tmpb_tl } }
  }
%    \end{macrocode}
% Write what previously was in the file as well as our new stuff.
%
%    \begin{macrocode}
  \iow_open:Nn \c_@@_outfile_iow { \c_@@_out_filename_tl }
  \iow_now:Nx  \c_@@_outfile_iow { \exp_not:V \l_tmpa_tl }
  \iow_now:Nx  \c_@@_outfile_iow { \exp_not:V \l_tmpb_tl }
  \iow_close:N \c_@@_outfile_iow
}
%    \end{macrocode}
% \end{macro}
%
% \subsection{Indexing}
% 
% \changes{0.0.6$\alpha$}{2022/03/21}{Better delimiter handling}
% \begin{macro}{\@@_safedelim:N}
%
% Here the letter |¤| has been chosen to be the delimiter for the \pkg{minted}/\pkg{listings} environments
%
% Each \LaTeX{} engine treats unicode a little bit differently. 
% In \pdfTeX{} one needs to define the full utf-8 hex code, but in \LuaTeX{} and \XeTeX{} one only needs the Unicode number. 
% 
% This results in a difference when calling between the two.
% Normally this would not be a big deal but because we are using these are the delimiters for Verbatim Environments we \emph{require} only a single character. 
%
% If we use |^^a4| in all engines \pdfTeX{} creates an error about not being utf-8. 
% If we use |^^c2^^a4| in all engines \LuaTeX{}/\XeTeX{} makes 2 characters and the delimiting doesn't work.
%
%    \begin{macrocode}
\cs_set:Npn \@@_codesafedelim:N #1 {
  \str_case_e:nn { \c_sys_engine_str } {
    { pdftex } { \str_set:Nn #1 { ^^c2^^a4 } }
    { luatex } { \str_set:Nn #1 {     ^^a4 } }
    { ptex   } { \str_set:Nn #1 { ^^c2^^a4 } }
    { uptex  } { \str_set:Nn #1 { ^^c2^^a4 } }
    { xetex  } { \str_set:Nn #1 {     ^^a4 } }
  }
}
%    \end{macrocode}
% \end{macro}
%
% \changes{0.0.6$\alpha$}{2022/03/21}{Move \cs{vindex} implementation into aux function}
%
%  \begin{macro}{\@@_vindex_aux:nx}
% This is the implementation of \cs{vindex}. 
% The reason that we use this aux function is to get around the restrictions of using verbatim commands inside other commands. 
% We use this function in both \cs{vindex} and \env{var} etc. 
%
% Note: I know this function is not optimal, and probably a really dumb way to do things.
% I do plan on refactoring into something more readable.
%
%    \begin{macrocode}
\cs_set:Npn \@@_vindex_aux:nx #1#2 {
  \str_set:Nn \l_@@_idxvar_str { #1 }
  \tl_set:Nx \l_@@_idxfmt_tl { #2 }
%    \end{macrocode}
%    \begin{macrocode}
  \tl_set:No \l_@@_verbstr_str { \c_backslash_str verb }
%    \end{macrocode}
% The delimiters used in \tn{verb} is |¤|. 
% This is |^^a4| in \LuaTeX{}, \XeTeX{},  and |^^c2^^a4| in \pdfTeX{}.
% (The c2 is needed because we need to explicitly write out the utf-8 hex)
%
% |¤| was picked because I don't know of any programming language that uses these in identifiers (or really anything). 
% However |¤| also works in \pdfTeX{} without needing to set catcodes. 
% Avoiding catcodes is important as these go into a \file{.idx} file and we have no local control over catcodes there.
% 
% (There is probably one language out there that uses |¤|, but this is the best delimiter that works that I can think of that works with the various index packages and doesn't require setting catcodes).
%
%    \begin{macrocode}
   \str_set:Nn \l_@@_verbdelim_str { ^^a4 } 
%    \end{macrocode}
% The regex here replaces ``|my!str|'' with ``|my¤!\verb¤str|''.
%
%    \begin{macrocode}
  \exp_args:Nnno \tl_replace_all:Nnn \l_@@_idxvar_str {!} {
    \l_@@_verbdelim_str!\l_@@_verbstr_str\l_@@_verbdelim_str
  }
%    \end{macrocode}
% This is just a convoluted way of saying ``|\verb¤|\cs{l_@@_idxvar_str}|¤|"|"\cs{indexfmt}'', but using catcode letter/other. 
%
%    \begin{macrocode}
  \tl_set:Nx \l_@@_idxvar_str { 
      \exp_not:V { \l_@@_verbstr_str   }
      \exp_not:V { \l_@@_verbdelim_str }
      \l_@@_idxvar_str
      \exp_not:V { \l_@@_verbdelim_str }
      | \l_@@_idxfmt_tl
  }
  \iow_term:x { \exp_not:o \l_@@_idxvar_str}
%    \end{macrocode}
% As mentioned, but with reiterating, \tn{index} is designed to be overwitten by whatever indexing package is being used. There is no need for a hard requirement on a specific package. 
%
%    \begin{macrocode}
  \exp_args:No \index { \l_@@_idxvar_str }
}
%    \end{macrocode}
% \end{macro}
%
% \subsection{Interfaces}
%
% \changes{0.0.6$\alpha$}{2022/03/21}{Move \cs{vindex} implementation into aux function}
%
% \changes{0.0.4$\alpha$}{2022/03/21}{Add \cs{vindex}}
%
% \begin{macro}{\vindex}
% Its often useful to create an index of all the functions/classes/etc at the bottom of the file.
% However, its impossible to pass code to search for meaning. 
%
% The aim of this macro is to be a wrapper to \tn{index} that places the arguments in a \tn{verb} environment so functions/etc can contain things like |_| and be set in monospace. 
% (The trick is to keep |!| out of the \tn{verb})
%
% The use of \tn{index} in this function is expected to be overwritten by \pkg{makeidx}/\pkg{xindy}/etc
%
%
%    \begin{macrocode}
\NewDocumentCommand \vindex { v } {
  \str_set:Nn \l_tmpa_str  { #1 }
  \exp_args:No \label { code: \l_tmpa_str }
  \exp_args:No \@@_vindex_aux:nx \l_tmpa_str { \vindexfmt }
}
%    \end{macrocode}
%\end{macro}
%
% \changes{0.0.7$\alpha$}{2022/06/05}{Format index different for definitions and calls.}
% \begin{macro}{\vindexfmtdef, \vindexfmtcall, \vindexfmt}
% Here we are defining a small collection of formatting options for the index. 
% 
% By default we make the pagenumber with the definition \textit{italic}, and all the calls to that definition \textrm{roman}. 
% Similarly, any \cs{vindex} call is going to be roman.
%
% These macros are left here incase someone wants to redefine them for their own style. 
%
%    \begin{macrocode}
\tl_set:Nn \vindexfmtdef { textit }
\tl_set:Nn \vindexfmtcall { textrm }
\tl_set:Nn \vindexfmt { textrm }
%    \end{macrocode}
%\end{macro}
%
% \subsection{hyperref}
%
% \changes{0.0.7$\alpha$}{2022/06/05}{Add calls of a function to the index.}
% \begin{macro}{\fortexhyperinsert}
% Because we have a few things that we want to do at the location of the regex insertion, we create our own macro to handle them.
%
% Here 3 things happen, the function gets registered into the index. 
% (unless noindex is specified, here by the $\ast$).
% As well as a hyperref link inserted with the text being the name of the function in the correct formatting.
%
% There is however a little bit of cruft around these calls due to a few limitations with \pkg{minted}'s escaping mechanism. 
% The main issue is that minted will not escape a string or a comment.
% Normally this isn't a huge deal but some languages I use (Fortran) use |!| as comments.
% This causes issues when inserting a string like |¤should be ! escaped¤| where |¤| is the escape char. 
% In this instance the escaped section does not actually get escaped and instead gets inserted into the minted formatting.
%
% To work around this we make sure to pass the code nesting structure as |class:function| and then do a string replacement to get it back into the form we want for indexing. 
% The reason that we use |:| and not a less frequently used character is to avoid the overhead of a second replacement.
% This may become an issue in the future, but for the languages that I work with it isn't. 
%
% The final interesting thing about this function is that it has to be callable with the default selection of letter catcodes. This means no |@| or |_:| characters. This is due to the contents being \tn{insert} by minted in the middle of the document, characters like |@_:| are still defined as catcode other. 
%
% Its not ideal, but it is the easiest way to deal with it
%
%    \begin{macrocode}
\NewDocumentCommand \fortexhyperinsert { s m m } {
  \tl_set:Nn \l_tmpa_tl { #3 }
  \str_replace_all:Nnn \l_tmpa_tl {:} {!}
  \bool_if:NF { #1 } {
    \exp_args:Nx \@@_vindex_aux:nx { \l_tmpa_tl } { \vindexfmtcall }
  }
  \hyperref [ code: #3 ] {
            \texttt{ \detokenize { #2 } } 
  }
}
%    \end{macrocode}
% \end{macro}
% \changes{0.0.6$\alpha$}{2022/03/21}{Create automatic insertions of hyperref into minted/listings}
% \begin{macro}{\@@_mkref_file:Nn}
%
% The easiest way to insert the hyper references, is to read in the file we are going to highlight, and then use some regex to modify it. 
% \cs{@@_mkref_file:nN} is dealing with the file creation and caching of the results side. 
% The actual call to the regex function, is in \cs{@@_mkref_file_aux} and is the slowest bit..
% Whats not contained in this function is the regex itself. That is contained in \env{codeblock}.
%
%    \begin{macrocode}
\cs_set:Npn \@@_mkref_file:nN #1#2 {
%    \end{macrocode}
% Because we don't care about the first pass, before the |.aux| file is created, it is quickest to not even bother regexing the code. 
%
%    \begin{macrocode}
  \tl_if_exist:NT { \fortex@codeblockregex } {
%    \end{macrocode}
% Here we are going to be using the md5 hash of the code we want to highlight as a simple way to check if we have already done the hard work.
% This is the biggest time-saver of the hyperrefing process, as nobody wants to do the same work twice.
%
%    \begin{macrocode}
    \tl_set:Nx \l_@@_ref_cache_filename_tl { \c_@@_tmpfolder_tl/
                                             \file_mdfive_hash:n { #1 } .tmp 
    }
    \file_if_exist:nF { \g_@@_outputdir_tl \l_@@_ref_cache_filename_tl } {
      \exp_args:Nxx \@@_mkref_file_aux:nn { #1 } { \l_@@_ref_cache_filename_tl }
    }
%    \end{macrocode}
% finally return the output file that we calculated \emph{without} the leading directory
% this needs to be done after \cs{@@_mkref_file_aux:nn}, due to clobbering
%
%    \begin{macrocode}
    \tl_set:Nx { #2 } { \l_@@_ref_cache_filename_tl }
  }
}
%    \end{macrocode}
% \begin{macro}{\@@_mkref_file_aux:nnn}
% This Macro does the hard work of doing the actual regexing and substituting. Before writing the contents back out to a file. 
% 
%    \begin{macrocode}
\iow_new:N \c_@@_reffile_iow
\cs_set:Npn \@@_mkref_file_aux:nn #1#2 {
  \file_get:nnN { #1 } { \@@_setcatcode: } \l_@@_filecontents_tl
%    \end{macrocode}
% Behold the slowest part in the code. 
% As mentioned elsewhere in this document I have tried a few different methods to speed this up including \cs{seq_map_indexed_inline:Nn}, but that just made things slower. 
% This dos mean that we are locked to \TeX{}Live 2022 as a min version though. 
% 
% I am not going to lie, getting the correct expansion of the \cs{l_tmpa_tl} macro was an absolute pain.
% This is mainly due to having to interleave the matching regex and the replacement, as well as keeping the brackets |{...}| intact.
%
% However it seems to be working now and I don't want to touch it. 
%    \begin{macrocode}
  \seq_if_empty:NF \fortex@codeblockregex { 
    \exp_args:NV \regex_replace_case_all:nN {
      \fortex@codeblockregex
    } \l_@@_filecontents_tl
  }
  \iow_open:Nn \c_@@_reffile_iow { #2 }
  \iow_now:Nx  \c_@@_reffile_iow { \exp_not:V { \l_@@_filecontents_tl } } 
  \iow_close:N \c_@@_reffile_iow  
}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \changes{0.0.6$\alpha$}{2022/03/30}{Add macro-like environments}
% \changes{0.0.7$\alpha$}{2022/06/04}{finish automatic hyperref}
% 
% This function exists to automatically add hyperlinks from the usage of a function to its definition somewhere else in the code. 
% At the moment this is not complete and I am still yet to add the * interfaces. 
%
% I plan for the * interfaces is to only track within the parent code block. This is mainly used for private functions that you don't want polluting.
%
% \begin{variable}{\g_@@_codenest_seq, \c_@@_codeblock_types_seq}
%    \begin{macrocode}
\seq_new:N \g_@@_codenest_seq
\seq_new:N \g_@@_codeblock_regex_toaux_seq
%    \end{macrocode}
% \end{variable}
%
% \begin{macro}{codeblock*, codeblock}
%    \begin{macrocode}
\NewDocumentEnvironment { codeblock } { O{} m } {
  \group_begin:
%    \end{macrocode}
% So one of the first things that we want to do is to is load our optional args clist into a sequence where we have functions to check if an arg is in later on.
% At the moment the only two options defined are |noindex| and |noref|.
%
% |noindex| is used to prevent the function from being registered with the index, and |noref| is used to prevent the automatic insertion of hyperlinks. 
%    \begin{macrocode}
  \seq_set_from_clist:Nn \l_@@_argv_seq { #1 }
%    \end{macrocode}
% Here \cs{l_@@_codename_str} is the name of the function/class/variable that we are going to track. 
% At the moment this is not fully sanitised and there may be problems if active catcodes come in, but for now it will do. 
% 
% Because we want to keep track of the nesting of the code -- two classes can have the same function name -- we add this to a stack, that we then read out of when we go to use the indexing. 
%
%    \begin{macrocode}
  \str_set:Nn \l_@@_codename_str { #2 }
  \seq_gput_right:Nx \g_@@_codenest_seq \l_@@_codename_str
%    \end{macrocode}
% We need to make a non-command version of the \tn{verb} command to make sure we can safely pass around and replace into the code.
% This is probs not the best way to do it. However if we use \tn{detokenize}, there will be a space after the \tn{verb}.
% This will then lead to the delimiters being incorrectly defined.  
%
% We also use the previously defined \cs{@@_codesafedelim:N} function, to get the |¤| char for the different \TeX{} engines. 
%
%    \begin{macrocode}
  \seq_if_in:NnF \l_@@_argv_seq { noref } {
    \tl_set:No \l_@@_verbstr_str { \c_backslash_str verb }
    \@@_codesafedelim:N \l_@@_printdelim_str
%    \end{macrocode}
% Here we create the matching regex, and the thing that is going to replace it.
% 
% Note that we construct the regex here as the number of times \env{codeblock} is called is going to be much less than the number of times we are going to have to search. 
% Thus we will create the regex and then hand it off to later be processed. 
%
% The regex is in 3 basic sections as follows
% \begin{table}[!h]
% \begin{tabular}{|c|p{10cm}|} \hline
% |(\W?[^:])| & The first |W| matches any non-letter character, the |?| modifies it so that it is able to match 0 or 1 occurrences greedily. \newline
% We then have a list of chars that we are going to say should never precede an identifier, but are accidentally matched by |\W|.
% At the moment this is only ``|:|''. \emph{This is important} because we could accidentally overwrite a previously inserted hyperref link as identifiers are formatted as code:name. If another search were to pass through I have seen it nest replacements. \newline 
% Finally we place this all in a capturing group to allow us to reinsert the char we would otherwise be replacing \\\hline
% |##1|       & This active sequence inserts the name of the function that we want to find. \\\hline
% |(\W)|      & Finally we match any non-letter and capture it to reinsert later. \\\hline
% \end{tabular}
% \end{table}
%
% The text that is getting replaced by looks complex, but simplifying is merely
% \begin{verbatim}
% \1¤\hyperref[code:identifier]{\psudoverb{name}}¤\2
% \end{verbatim}
%
% where |\1| and |\2| are the two previously captured groups.
%    \begin{macrocode}
    \seq_if_in:NnTF \l_@@_argv_seq { noindex } {
        \tl_set:Nn \l_tmpa_tl { fortexhyperinsert* }
    }{
        \tl_set:Nn \l_tmpa_tl { fortexhyperinsert }
    }
    \tl_set:Nn \l_tmpa_regex {(\W?[^:])#2(\W)}
    \str_set:Nx \l_tmpa_str {
                  \exp_not:n { \1                     }
                              \l_@@_printdelim_str
                  \exp_not:n { \\                     }
                              \l_tmpa_tl
                  \exp_not:n { \{                     }
                              \l_@@_codename_str
                  \exp_not:n { \} \{                  }
                              \seq_use:Nn \g_@@_codenest_seq {:}
                  \exp_not:n { \}                     }
                              \l_@@_printdelim_str
                  \exp_not:n { \2                     }
    }
%    \end{macrocode}
% One thing I should not is that yes: I do actually know about pre-compiling regex using \cs{regex_set:Nn}.
% However, I have decided to not to do that due to a few reasons.
%
% The first is that when you precompile \pkg{expl3} regex, all groups lose their capturing ability.
% In effect this means that the regex |(...)| gets turned into a |(?:...)|. 
% This for me doesn't work as I need to be able to detect if we are substituting a substring of a larger word. 
% This might be a solved problem without capture groups, but I don't know it. 
%
% So one might think ``ok, capture groups don't work, lets just change the regex passed to \cs{regex_replace_case_all} to something akin to |(\ur{regex_one})##1(\ur{regex_two})|.
% Thus precompiling the bits at the end, but leaving the capture groups out of the precompile. 
% This also doesn't work as by using \pkg{l3benchmark}, there seems to be no difference in speed, and only gives added complexity.
%
% Finally for completeness I have also tried using \cs{seq_map_indexed_inline:Nn} over a regular call to \cs{regex_replace_all:nnN} however, this is \emph{much} slower (about $2 \times$). 
%
% Doing it all this way does mean that I am stuck with using a minimum version of \TeX{}Live 2022.
% In the future I would like to have a fallback method that will work with \TeX{}Live 2015, due to that's what the stable distros seem to be supporting. 
%
%    \begin{macrocode}
    \seq_gpush:Nx \g_@@_codeblock_regex_toaux_seq { { \exp_not:V \l_tmpa_str }  }
    \seq_gpush:Nx \g_@@_codeblock_regex_toaux_seq { { \exp_not:V \l_tmpa_regex } }
%    \end{macrocode}
% Finally we add the bits of code that are linked to. 
% At the moment this is a \label{identifier}, as well as adding the name to the index.
% 
% I want to make an option in the future that will control if the codeblock/variable name is added to the index or not (sometimes it is useful not to).
% But for now this is everything.
% 
%    \begin{macrocode}
    \exp_args:Nx \label { code: \seq_use:Nn \g_@@_codenest_seq {:}  }
  }
  \seq_if_in:NnF \l_@@_argv_seq { noindex } {
    \exp_args:Nx \@@_vindex_aux:nx { \seq_use:Nn \g_@@_codenest_seq {!} } { \vindexfmtdef }
  }

} {
%    \end{macrocode}
% 
% This next section will insert into the |.pdf| after the codeblock:
% \begin{center}
% \noindent\textit{\small{End of code block |codeblock|}}\\
% \end{center}
%
% after we are finished defining a code block. This is designed to be similar to \LaTeX{}'s \pkg{doc} package.
% 
% This also has the added effect of moving up one level in the nesting.
%    \begin{macrocode}
  \noindent\textit{
    \small
    End~of~code~block~
    \seq_if_in:NnF \l_@@_argv_seq { noref } {
      \hyperref [ code: \seq_use:Nn \g_@@_codenest_seq {:} ]
    }
                { \texttt{\detokenize{ #2 }}}.\\
    \seq_gpop_right:NN \g_@@_codenest_seq \l_tmpa_tl
  }
  \group_end:
}
%    \end{macrocode}
% Because we are adding the functions we want to tracked as they are defined, we are unable to add a hyperref a usage before the definition. 
% 
% For this reason we don't bother hyperrefing on the first passthough and instead just generate the regex for the next. 
% This way we are able to get the correct hyperrefing on the second passthough. 
%
% Like the previous write to |.aux| we use the old \LaTeXe{} syntax to prevent the insertion of \tn{ExplSyntaxOn} in the |.aux| file.
% 
%    \begin{macrocode}
\hook_gput_code:nnn { enddocument } { fortex } {
  \iow_now:cx { @auxout } {
     \exp_not:n { \gdef\fortex@codeblockregex }
     { \seq_use:Nn \g_@@_codeblock_regex_toaux_seq { } }
  }
}
%    \end{macrocode}
% \end{macro}
%
% \subsection{Other interfaces}
% 
% \begin{macro}{\setfortex}
%
% Keep fortex options separate from global \pkg{minted}/\pkg{listings} options.
% (this just gets passed though. But is separate to allow separate calls (e.g. inline code examples) to \pkg{minted}/\pkg{listings} to behave differently to the \env{code} environment ).
% 
% At the moment we are using a token list, and I would like to change this sometime so other parts of the code are better handled.
% (My suspicion is that I can avoid the required \cs{exp_args:No} in the call to \cs{@@_printcode:} by using a better type.)
%
%    \begin{macrocode}
\clist_new:N \g_@@_formatopt_clist
\NewDocumentCommand \setfortex { m } {
  \clist_gset:Nn \g_@@_formatopt_clist { #1 }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{environment}{code}
% The actual environment that gets called.
% There are a few things about this function that are not optimal, but I have tried and cannot think of any more elegant way to do them.
% 
% The main issue is that there seems to be no way to have a verbatim environment that allows the insertion of the content into two locations, or to insert into a command argument. 
% We want to do this because we need to:
%
% \begin{enumerate}
% \item{Append verbatim content to file}
% \item{Highlight and print in the |.pdf|}
% \end{enumerate}
%
% As such we go on a whole side-quest into writing to folders and detecting output directories, etc. 
% All because of this one issue.
% I have had a look at other solutions including \pkg{skdoc} and \pkg{minted}, and they seem to do the same thing of writing out to a file and then reading back in.
% Our implementation is both more advanced and jankier as we, unlike the previously mentioned packages are able to handle |-output-dir| flags batter and do not have a hard |-shell-esc| requirement. 
% However, in doing so we have jank and workarounds. 
%
% (Note: \tn{VerbatimEnvironment} is needed to detect the end of the environment when using verbatim content)
%    \begin{macrocode}
\NewDocumentEnvironment { code } {} {
  \VerbatimEnvironment
  \@@_firstcall:
  \@@_inctmpname:
%    \end{macrocode}
% One interesting thing to note, is that \tn{VerbatimOut} does not require the name catcode settings as when we are doing the append operations in \cs{@@_concat_files:}.
% And I don't know why?
%    \begin{macrocode}
  \VerbatimOut [ codes = { \char_set_catcode_other:N \^^I } ]
                               { \g_@@_tmp_filename_tl }
%    \end{macrocode}
% If we are using |-output-dir|, we need to pass full name to \pkg{minted}/\pkg{listings}
%    \begin{macrocode}
}{
  \endVerbatimOut
%    \end{macrocode}
% Don't build on the first passthough.
% searching for links is \emph{excruciatingly} slow, so avoid doing it unnecessarily.
% If we \emph{do} build on the first pass then this also makes our caching strategy invalid as the actual code will not have changed. 
% Hence the cache will not be invalidated.
%
%    \begin{macrocode}
  \tl_if_exist:NT { \fortex@outputdir } {
    \@@_concat_files:
    \benchmark_tic:
    \@@_mkref_file:nN { \g_@@_outputdir_tl\g_@@_tmp_filename_tl }
                              \l_tmpa_tl
    \benchmark_toc:
    \exp_args:No \@@_printcode:nnn { \g_@@_formatopt_clist }
                                           \g_@@_lang_tl
                                         { \g_@@_outputdir_tl\l_tmpa_tl } 
  }
}
%    \end{macrocode}
% \end{environment}
%
% \end{implementation}
%    \begin{macrocode}
%</package>
%    \end{macrocode}
%
% \PrintChanges
% \PrintIndex
%
