\RequirePackage[enable-debug]{ expl3 }
\ProvidesExplPackage {fortex} {2022-02-01} {0.0.4a} {somewhere between Jupyter and WEB}

\RequirePackage { l3keys2e }

% fancyvrb is required to write stuff to file & to define custom verb environment
\RequirePackage { fancyvrb }

%%%%%%%%%%%%%%%%%%%%%%%%%% Package Setup %%%%%%%%%%%%%%%%%%%%%%%%%%%

% \debug_on:n {all}

% package options
\keys_define:nn { fortex } {
	% print code to console
	verbose .bool_set:N = \l_fortex_verbose_bool,
	verbose .default:n  = { true },
	verbose .initial:n  = { false },
	
	% what backend to make the pdf
	print .tl_set:N  = \l_fortex_preprintend_str,
	print .default:n = { listings },
	print .initial:n = { listings },
	
	% what language we talkn
	language .tl_set:N  = \l_fortex_lang_str,
	language .default:n = { text },
	language .initial:n = { text },
	
  %	override extension detection
	ext .tl_set:N  = \l_fortex_ext_str,
	ext .initial:n = {},
	ext .default:n = {},
}
\ProcessKeysOptions { fortex }


%
% set alternative printing names
%
\msg_new:nnn { fortex } { printend } {
	Unknown ~ keyval ~ "print=#1". ~ defaulting ~ to ~ "print=listings"
}
\str_case_e:nnF { \l_fortex_preprintend_str} {
	{minted}      { \tl_set:Nn \l_fortex_printend_str {mint} }
	{mint}        { \tl_set:Nn \l_fortex_printend_str {mint} }
	{m}           { \tl_set:Nn \l_fortex_printend_str {mint} }

	{lstlistings} { \tl_set:Nn \l_fortex_printend_str {lst} }
	{lstlisting}  { \tl_set:Nn \l_fortex_printend_str {lst} }
	{listings}    { \tl_set:Nn \l_fortex_printend_str {lst} }
	{listing}     { \tl_set:Nn \l_fortex_printend_str {lst} }
	{lst}         { \tl_set:Nn \l_fortex_printend_str {lst} }
	{l}           { \tl_set:Nn \l_fortex_printend_str {lst} }
}{
	\tl_set:Nn \l_fortex_printend_str {list}
	\msg_warning:nnx { fortex } { printend } { \l_fortex_preprintend_str }
}



%%%%%%%%%%%%%%%%%%%%%%%%%% Engine Setup %%%%%%%%%%%%%%%%%%%%%%%%%%%%

% \char_set_catcode_other \^^I has problems in XeTeX pTeX and uptex due to not using real tab chars?
% this seems to be resolved by using -8bit
% tex.stackexchange.com/questions/14771
% tex.stackexchange.com/questions/58732
% tex.stackexchange.com/questions/264461
\bool_if:nT { \l_fortex_verbose_bool } {
	
	\msg_new:nnn { fortex } { itab } {
		#1 ~ has ~ problems ~ printing ~ tabs ~ to ~ files. ~ (tabs ~ may ~ turn ~ into ~ 
		~ \c_circumflex_str \c_circumflex_str I) ~ Executing ~ with ~ -8bit ~ may ~ fix ~ this.
	}
	\str_case_e:nnT { \c_sys_engine_str } {
		{ eptex  } {}
		{ euptex } {}
		{ ptex   } {}
		{ uptex  } {}
		{ xetex  } {}
	} {
		\msg_warning:nnx { fortex } { itab } { \c_sys_engine_str }
	}
	
}
 
 
%%%%%%%%%%%%%%%%%%%% Helper Functions %%%%%%%%%%%%%%%%%%%%%


%
% if LaTeX is used with -output-directory, \sys_shell_now:x {mkdir ...} will ignore it and make
% it's directory in the .tex directory. However \VerbatimOut will write to the file indicated 
% by -output-directory. This causes problems if \VerbatimOut tries to write into our newly made 
% directory.
%
% we try to work around this by using a little bit of regex and a quirk of log files:
% for this example let the command be "latex -output-dir=outdir jobdir/jobname.tex"
%
% if there is a .aux file aleady in jobdir/ then the log file will list the lines
%
% (/path/to/jobdir/jobname.aux)
% \openout1 = `jobname.aux'.
%
% however if there _IS NOT_ an .aux file already in jobdir/ it is a diffrent story:
%
% (/path/to/outdir/jobname.aux)
% \openout1 = `jobname.aux'.
%
% moreover jobname.aux will always have the string
%
% /path/to/jobname/jobname.tex
%
% from this we can tell if we are running using -output-dir, and if so what -output-dir is   
%
% things to note however: 
% this trick ONLY works if there is not .aux in jobdir/
% with fortex, we can check if this is a first time run by checking the presence of a test file 
% but if you are copying this code into your own LaTeX file you will need to make sure that you 
% have a clean jobdir.
%
% also note: this command cannot be executed on setup - very sad, as the .aux log line appears 
% after most packages are loaded
% Maybe a hook in the future?
%
%
% also also note: this seems to be crahsing on XeLaTeX:
% ! Bad register code (32768)
% A register must be between 0 and 32767
% TODO: FIXME

\cs_set:Npn \__fortex_outputdir:N #1 {
		
	% read log file 
	\file_get:nnN { \c_sys_jobname_str .log } {
		\endlinechar=`\^^J
		\char_set_catcode_other:N \^^J
	} \l_tmpa_tl
	
	% get full path of .aux
	\exp_args:Nno \regex_extract_once:nnN {\.?/[-\.\w+/]*\.aux} { \l_tmpa_tl } \l_tmpa_seq
	\seq_pop_left:NN \l_tmpa_seq \l_fortex_realauxpath_tl
	
	% get full path of .tex
	\exp_args:Nno \regex_extract_once:nnN {\.?/[-\.\w+/]*\.tex} { \l_tmpa_tl } \l_tmpa_seq
	\seq_pop_left:NN \l_tmpa_seq \l_fortex_realtexpath_tl
	
	% log file is big so clean up 
	\tl_clear:N \l_tmpa_tl
	
	% strip the filenames off the end of the paths - makes it easier to check if aux is in a diffrent dir 
	\file_parse_full_name:VNNN {\l_fortex_realauxpath_tl} \l_fortex_realauxpath_tl \l_tmpa_tl \l_tmpa_tl
	\file_parse_full_name:VNNN {\l_fortex_realtexpath_tl} \l_fortex_realtexpath_tl \l_tmpa_tl \l_tmpa_tl
	
	% finally return the location of -output-dir=outdir if we have one, otherwise return nothing
	\str_if_eq:NNTF { \l_fortex_realauxpath_tl }{ \l_fortex_realtexpath_tl } {
		\tl_set:Nn #1 {}
	}{
		\tl_set:Nn #1 { \l_fortex_realauxpath_tl }
		\seq_gpush:NV \l_file_search_path_seq { \l_fortex_realauxpath_tl }
	}
	
	\bool_if:NT \l_fortex_verbose_bool {
		\iow_term:x { .aux path ~ \exp_not:V { \l_fortex_realauxpath_tl } }
		\iow_term:x { .tex path ~ \exp_not:V { \l_fortex_realtexpath_tl } }
	}
}


 
%%%%%%%%%%%%%%%%%%%% Code Printing %%%%%%%%%%%%%%%%%%%%%%%%

%
% load minted or listings
%
\str_if_eq:NNTF { \l_fortex_printend_str } { mint } {
	\RequirePackage { minted }
	\minted@cachefalse
	% figure out how to remove race conditions so cache need not be false and compilation speeds up
}{
	\RequirePackage { listings }
}


%
% because we need to expand the the args fully - something minted/listings doesnt do
% it is easier to pass this out to a function and use \exp_args:No
%
% \__inputcode:nnn {printing keys} {langauge} {filename}
%
% bugs: this function is weird, and I have no idea why onn or xnn doesnt work?
%       but calling \exp_args:No \__inputcode{}{}{} does work?
%
\cs_set:Npn \__inputcode:nnn #1#2#3 {
	
	\str_if_eq:NNTF { \l_fortex_printend_str } { mint } {
		\inputminted [ #1 ] { #2 } { #3 }
	}{
		\str_if_eq:NNTF { #2 } { text } {
			% listings doesnt support language=text
			\lstinputlisting [ #1 ] { #3 }
		}{
			\lstinputlisting [ language=#2, #1 ] { #3 }
		}
	}
	
}


%%%%%%%%%%%%%%%%%%%%%%%%% Filename Setup %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%
% guess the file extension if none is provided - default to .txt
%
\tl_if_empty:NT \l_fortex_ext_str {
	
	\msg_new:nnn { fortex } { language } {
		Unable ~ to ~ guess ~ file ~ extension ~ for ~ "language=#1". ~ defaulting ~ to ~ .txt
	}
	
	\str_case_e:nnF { \l_fortex_lang_str } {
		{python}      { \tl_set:Nn \l_fortex_ext_str {py}  }
		{fortran}     { \tl_set:Nn \l_fortex_ext_str {f90} }
		{fortranfixed}{ \tl_set:Nn \l_fortex_ext_str {f}   }
		{bash}        { \tl_set:Nn \l_fortex_ext_str {sh}  }
		{text}        { \tl_set:Nn \l_fortex_ext_str {txt} }
		{octave}      { \tl_set:Nn \l_fortex_ext_str {m}   }
		{matlab}      { \tl_set:Nn \l_fortex_ext_str {m}   }
		{cpp}         { \tl_set:Nn \l_fortex_ext_str {cpp} }
		{c}           { \tl_set:Nn \l_fortex_ext_str {c}   }
		{tcl}         { \tl_set:Nn \l_fortex_ext_str {tcl} }
		{nasm}        { \tl_set:Nn \l_fortex_ext_str {s}   }
		{makefile}    { \tl_set:Nn \l_fortex_ext_str {mk}  }
		% need to add more language / file extensions relations, but these are all the ones I will use 
		% myself. Idk if anyone else will use this.
	}{
		% default to .txt if we cannot figure it out
		\tl_set:Nn \l_fortex_ext_str { txt }
		\msg_warning:nnx { fortex } { language } { \l_fortex_lang_str }
	} 
}


%
% build tmp folder
% tmpfolder = _fortex-jobname/ 
%
\tl_set:Nn \l_fortex_tmpfolder_tl { \c_underscore_str fortex- \c_sys_jobname_str }


%
% check if tmp folder exists, and create it if it doesnt / if we can.
% not gunna lie this is kinda janky, but LaTeX doesnt support checking if a folder exists.
% ideally find a better method of doing this.
%
% \sys_if_folder_exists:nF {       %% this doesnt exist sadly
%
% to do this we check if the text file _fortex-jobname/jobname-0.tmp exists:
% if it doesn't, maybe the folder doesn't? 
% if the folder doesn't exist, this will say the same thing as the file not existing
% 
% if shell-esc is enabled, we run mkdir and move on.
% if not we warn the user that the next step may fail and stop the compilation 
%
% finally we try writing to the test file. if the folder doesnt exist this will stop the compilation 
% (we dont have shell-esc permissions to make a folder anyway do no big deal.)
%
\cs_set:Npn \__fortex_mktmpdir: {

	\file_if_exist:nF { \l_fortex_tmpfolder_tl/\c_sys_jobname_str -0.tmp } {
		
		% get the -output-dir flag 
		% don't run on xetex due to horrible crashing
 		\str_if_eq:NNF { \c_sys_engine_str } { xetex } {
			\__fortex_outputdir:N \l_fortex_outputdir_tl 
		}
		
		\sys_if_shell_unrestricted:TF {
			\sys_shell_now:x { mkdir ~ \l_fortex_outputdir_tl/\l_fortex_tmpfolder_tl }
		}{
			% throw a warning that we cannot open out test file & explain how to resolve it
			\msg_new:nnn { fortex } { make_folder } {
				Unable ~ to ~ find ~ folder ~ "##1" ~ please ~ create ~ it ~ manually, ~
				~ or ~ enable ~ -shell-esc ~ to ~ create ~ automatically
			}
			\msg_warning:nnx { fortex } { make_folder } { \l_fortex_tmpfolder_tl }
		}
		% create file for next time -- this will cause an error if the folder still does not exist
		\iow_new:N   \l_fortex_testfile_iow
		\iow_open:Nn \l_fortex_testfile_iow { \l_fortex_tmpfolder_tl/\c_sys_jobname_str -0.tmp }
		\iow_now:Nx  \l_fortex_testfile_iow { \exp_not:x \l_fortex_outputdir_tl }
		\iow_close:N \l_fortex_testfile_iow
	}
	
}

%
% build the tmp filenames - filename increments on every call 
%
% first call is 
% #1 = _fortex-jobname/jobname-1.tmp
% 
\int_new:N \l_fortex_inctmpname_namecount_int
\cs_set:Npn \__fortex_inctmpname:N #1 {
	\int_gincr:N \l_fortex_inctmpname_namecount_int
	\tl_set:Nn \l_tmpa_tl { \c_sys_jobname_str - \int_to_arabic:n{\l_fortex_inctmpname_namecount_int} .tmp }
	\tl_gset:Nn #1 { \l_fortex_tmpfolder_tl / \l_tmpa_tl }
}

%
% build the filename we are going to save the concatinated code segments to
%
% jobname.ext
% 
\tl_set:Nn \c_fortex_out_filename_tl { \c_sys_jobname_str.\l_fortex_ext_str }

%
% some setup code that should happen on the first call after everything is loaded
%

\iow_new:N \c_fortex_outfile_iow
\bool_const:Nn \l_fortex_firstrun_bool { \c_true_bool }

\cs_set:Npn \__fortex_firstcall:N #1 {
	\bool_if:nT { \l_fortex_firstrun_bool } {
		
		% create the tmpfolder
		\__fortex_mktmpdir:
		
		% clear the file on first run
		\str_set:Nx \l_tmpa_str #1
		\iow_open:Nn \c_fortex_outfile_iow { \l_tmpa_str }
		\iow_close:N \c_fortex_outfile_iow
		
		% no longer first run
		\bool_gset_false:N \l_fortex_firstrun_bool
	}
}

%%%%%%%%%%%%%%%%%%%%% Code Saving %%%%%%%%%%%%%%%%%%%%%%%%%%

%
% set catcodes required to not mangle the file. 
%

\cs_set:Nn \__fortex_setcatcode: {
	\endlinechar=`\^^J                % fallback to 2ε, expl3 has yet to make an interface
	\char_set_catcode_other:N \^^J
	\char_set_catcode_other:N \^^I
	\char_set_catcode_other:N \       % trailing spaces after \ needed
	\char_set_catcode_active:N \#
}


%
% \__fortex_writecode:nn {out_filename} {tmp_filename}
%
% save code function.
%
% appeand the contents of tmp_filename to out_filename
% if this is the first call, clear the previous contents of out_filename before appending
%
% this function mainly just performs a concatination of the previous code segment to the new one
% however as LaTeX does not support opening files in append mode, we need to do a read-write op
% in order to simulate it 
%

\cs_set:Npn \__fortex_writecode:nn #1#2 {
	
	% set to tmp variables as \file_get:nnN doesn't like filename=#1 
	\str_set:Nx \l_tmpa_str #1
	\str_set:Nx \l_tmpb_str #2
	
	% read from out_filename and tmp_filename
	\file_get:nnN { \l_tmpa_str } { \__fortex_setcatcode: } \l_tmpa_tl
	\file_get:nnN { \l_tmpb_str } { \__fortex_setcatcode: } \l_tmpb_tl
	
	% print tmpfile to terminal for debugging
	\bool_if:nT { \l_fortex_verbose_bool }{
		\iow_term:x { \exp_not:V { \l_tmpb_tl } }
	}
	
	% write what previously was in the file & our new stuff 
	\iow_open:Nn \c_fortex_outfile_iow { \l_tmpa_str }
	\iow_now:Nx  \c_fortex_outfile_iow { \exp_not:V \l_tmpa_tl }
	\iow_now:Nx  \c_fortex_outfile_iow { \exp_not:V \l_tmpb_tl }
	\iow_close:N \c_fortex_outfile_iow
}


%%%%%%%%%%%%%%%%% Interface %%%%%%%%%%%%%%%%%

%
% keep fortex options seperate from global minted/listings options
% (this just gets passed though. But is seperate to allow \mintinline{}{} to behave diffrently 
% to \begin{code} )
%
% default = {}
%
\tl_set:Nn \l_fortex_formatopt_tl {}

\NewDocumentCommand \setfortex { m } {
	\tl_set:Nn \l_fortex_formatopt_tl { #1 }
}

%
% the actual environment
%
% (\VerbatimEnvironment is needed to detect the end of the environment)
%  
%
\NewDocumentEnvironment { code } {} {%
	\VerbatimEnvironment
	\__fortex_firstcall:N \c_fortex_out_filename_tl
	\__fortex_inctmpname:N \l_fortex_tmp_filename_tl

	\VerbatimOut [ codes={\char_set_catcode_other:N \^^I} ] { \l_fortex_tmp_filename_tl }
}{
	\endVerbatimOut
	\exp_args:No \__inputcode:nnn { \l_fortex_formatopt_tl } \l_fortex_lang_str \l_fortex_tmp_filename_tl
	\__fortex_writecode:nn {\c_fortex_out_filename_tl} {\l_fortex_tmp_filename_tl}
}
